{
  
    
        "post0": {
            "title": "Working with color in seaborn",
            "content": "Title: large juypter notebook test Date: 2010-12-03 10:20 Category: Review . %run -i &quot;standard_header.py&quot; %matplotlib inline . import matplotlib as mpl mpl.rcParams[&quot;figure.dpi&quot;] = 300 . Setting a color . For charts where we&#39;re not using color to represent anything, we can generally pass an argument to the function to set the color. For the relplot function, the argument is simply color, and we can set it either with a named color: . sns.relplot( data=athletes, x=&quot;Age&quot;, y=&quot;Height (cm)&quot;, color=&quot;purple&quot;, ) plt.title(&quot;Height vs age for Olympic swimmers&quot;) . Text(0.5, 1.0, &#39;Height vs age for Olympic swimmers&#39;) . or a hexadecimal color code: . sns.relplot( data=athletes, x=&quot;Age&quot;, y=&quot;Height (cm)&quot;, color=&quot;#00b3c7&quot;, ) plt.title(&quot;Height vs age for Olympic swimmers&quot;) . Text(0.5, 1.0, &#39;Height vs age for Olympic swimmers&#39;) . or a tuple of values between 0 and 1 representing red, green and blue components: . sns.relplot( data=athletes, x=&quot;Age&quot;, y=&quot;Height (cm)&quot;, color=(1, 0.5, 0), ) plt.title(&quot;Height vs age for Olympic swimmers&quot;) . Text(0.5, 1.0, &#39;Height vs age for Olympic swimmers&#39;) . You can easily find online tools to help you pick colors. A useful resource is a list of HTML color names: . https://en.wikipedia.org/wiki/Web_colors#HTML_color_names . Working with palettes . For single color examples like the ones above, the choice of color doesn&#39;t play a huge role in the readability of the chart. As long as we avoid picking colors that are too low contrast to be seen easily: . sns.relplot( data=athletes, x=&quot;Age&quot;, y=&quot;Height (cm)&quot;, color=&quot;mintcream&quot;, # too similar to white! ) plt.title(&quot;Height vs age for Olympic swimmers&quot;) . Text(0.5, 1.0, &#39;Height vs age for Olympic swimmers&#39;) . we cannot go far wrong. In fact, many simple charts look great without any use of color at all: . sns.catplot( data=swimming[swimming[&quot;Distance (m)&quot;] == 100], kind=&quot;box&quot;, x=&quot;Stroke&quot;, y=&quot;Time (s)&quot;, color=&quot;white&quot;, height=6, ) plt.title(&quot;Distribution of 100m swimming times for different strokes&quot;, y=1.05) . Text(0.5, 1.05, &#39;Distribution of 100m swimming times for different strokes&#39;) . However, most of the time we will be using color to represent something in our charts - either a numerical variable, or a category. Whenever we are working with more than one color, we are dealing with a palette. . Palettes for sequential data . To change the color scheme for most plots, we use the palette argument. There are many different ways to use this argument, but for now the easiest is to pass in the name of an existing matplotlib palette. The matplotlib palettes are divided into different types; for numerical data like we have here, we need a sequential palette. . For convenience, here&#39;s a figure showing the most useful sequential palettes - these are the ones where higher values map to more saturated colors, which tend to be easiest to interpret: . fig, ax = plt.subplots() from scipy import ndimage i = plt.imread(&quot;colormaps_sequential_1.png&quot;) plt.imshow(ndimage.rotate(i, -90)) ax.axis(&quot;off&quot;) . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . (-0.5, 1499.5, 2999.5, -0.5) . Let&#39;s take our plot of age versus height, and use color to represent the athlete weight: . sns.relplot( data=athletes, x=&quot;Age&quot;, y=&quot;Height (cm)&quot;, hue=&quot;Weight (kg)&quot;, palette=&quot;YlOrBr&quot;, ) plt.title(&quot;Age vs height for Olympic swimmers&quot;) . Text(0.5, 1.0, &#39;Age vs height for Olympic swimmers&#39;) . It&#39;s often tempting to use one of the various &quot;rainbow&quot; palettes, as they produce very colorful charts: . sns.relplot( data=athletes, x=&quot;Age&quot;, y=&quot;Height (cm)&quot;, hue=&quot;Weight (kg)&quot;, palette=&quot;Spectral&quot;, ) plt.title(&quot;Age vs height for Olympic swimmers&quot;) . Text(0.5, 1.0, &#39;Age vs height for Olympic swimmers&#39;) . But these tend to make interpretation harder as they represent changes in value with different colors rather than different shades of the same color as in the sequential color maps. . All of the named sequential palettes in the figure above can be reversed by adding _r onto the end of the name. So we can map higher values to lighter colors: . event = swimming[ (swimming[&quot;Distance (m)&quot;] == 400) &amp; (swimming[&quot;Stroke&quot;] == &quot;freestyle&quot;) ] sns.relplot( data=event, x=&quot;Height (cm)&quot;, y=&quot;Time (s)&quot;, hue=&quot;Year&quot;, palette=&quot;OrRd_r&quot;, ) plt.title(&quot;Athlete height vs time for 400m freestyle Olympic swimmers&quot;) . Text(0.5, 1.0, &#39;Athlete height vs time for 400m freestyle Olympic swimmers&#39;) . Given the wide range of built in palettes, it&#39;s relatively rare that we have to reach for anything else. However, if we want a custom palette we can take a single color and create a palette using the light_palette or dark_palette functions. Confusingly, we need light_palette if we are starting with a dark color, and vice versa. So to build a palette starting with a purple color: . sns.relplot( data=swimming, x=&quot;Age&quot;, y=&quot;Height (cm)&quot;, hue=&quot;Weight (kg)&quot;, palette=sns.light_palette(&quot;purple&quot;, as_cmap=True), ) plt.title(&quot;Age vs height for Olympic swimmers&quot;) . Text(0.5, 1.0, &#39;Age vs height for Olympic swimmers&#39;) . Palettes for categorical data . All of the palettes in the previous section have been sequential: i.e. similar values get mapped to similar colors. That&#39;s exactly what we want for numerical data, as it makes it possible to see patterns and trends. However, this is exactly what we don&#39;t want for categorical data. Consider our box plot from before: . sns.catplot( data=swimming[swimming[&quot;Distance (m)&quot;] == 100], kind=&quot;box&quot;, x=&quot;Stroke&quot;, y=&quot;Time (s)&quot;, color=&quot;white&quot;, height=4, ) plt.title(&quot;Distribution of 100m swimming times for different strokes&quot;, y=1.05) . Text(0.5, 1.05, &#39;Distribution of 100m swimming times for different strokes&#39;) . and let&#39;s add some color: . sns.catplot( data=swimming[swimming[&quot;Distance (m)&quot;] == 100], kind=&quot;box&quot;, x=&quot;Stroke&quot;, y=&quot;Time (s)&quot;, palette=&quot;BuGn&quot;, height=4, ) plt.title(&quot;Distribution of 100m swimming times for different strokes&quot;, y=1.05) . Text(0.5, 1.05, &#39;Distribution of 100m swimming times for different strokes&#39;) . This is certainly prettier to look at, but the problem is that the colors are now actively misleading. The fact that freestyle and backstroke are a similar color will trick our brains into thinking that they are similar in some way. In fact, the reason they have similar colors in this plot is that they happened to appear in that order in the dataset. . For categories without a natural order, we want a qualitative palette. In seaborn we can choose from Set1, Set2, Set3, Pastel1, Pastel2, Dark2 and Accent. All of these palettes have been designed to avoid having similar colors next to each other: . fig, ax = plt.subplots() from scipy import ndimage i = plt.imread(&quot;colormaps_categorical.png&quot;) plt.imshow(ndimage.rotate(i, -90)) ax.axis(&quot;off&quot;) . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . (-0.5, 1499.5, 1499.5, -0.5) . and if we pick one for our box plot, it looks much better: . sns.catplot( data=swimming[swimming[&quot;Distance (m)&quot;] == 100], kind=&quot;box&quot;, x=&quot;Stroke&quot;, y=&quot;Time (s)&quot;, palette=&quot;Set2&quot;, height=4, ) plt.title(&quot;Distribution of 100m swimming times for different strokes&quot;, y=1.05) . Text(0.5, 1.05, &#39;Distribution of 100m swimming times for different strokes&#39;) . and will help us to avoid misinterpreting color. . In the simple box plot above, the color doens&#39;t really add anything except to make the plot more attractive. However, as soon as we have multiple plots, color can play a much more important role. For example, let&#39;s turn this plot into a small multiple by drawing a separate chart for each year: . g = sns.catplot( data=swimming[ (swimming[&quot;Distance (m)&quot;] == 100) &amp; (swimming[&quot;Year&quot;]).between(1980, 2010) ], kind=&quot;box&quot;, x=&quot;Stroke&quot;, y=&quot;Time (s)&quot;, palette=&quot;Dark2&quot;, height=3, col=&quot;Year&quot;, col_wrap=4, ) g.fig.suptitle( &quot;Distribution of 100m swimming times for each stroke in different Olympic years&quot;, y=1.05, ) . Text(0.5, 1.05, &#39;Distribution of 100m swimming times for each stroke in different Olympic years&#39;) . Now the color becomes much more useful. Even though it shows us redundant information - it tells us the stroke, which is also labelled on the x axis - it&#39;s much easier to find the matching boxes between different year plots. . Color will also be very useful when we want to use the same categories across multiple plots of different types. Let&#39;s draw a matching set of small multiple scatter plots showing age versus height that are also colored by stroke: . g = sns.relplot( data=swimming[ (swimming[&quot;Distance (m)&quot;] == 100) &amp; (swimming[&quot;Year&quot;]).between(1980, 2010) ], x=&quot;Age&quot;, y=&quot;Height (cm)&quot;, palette=&quot;Dark2&quot;, height=3, col=&quot;Year&quot;, col_wrap=4, hue=&quot;Stroke&quot;, ) g.fig.suptitle( &quot;Age vs height for 100m Olympic swimmers in each stroke for different years&quot;, y=1.05, ) . Text(0.5, 1.05, &#39;Age vs height for 100m Olympic swimmers in each stroke for different years&#39;) . Cross referencing this plot with the previous one is a tricky task, but one that is made much easier if we use consistent colors for the categories - in this case, strokes. Let&#39;s say we notice that one of the green points in the scatter plot for 1992 is much taller than the other athletes, and want to check if there are also outliers in time for this event in this year. Without matching colors in the box plots we&#39;d have to check the legend of the scatter plots to find out which stroke corresponds to green, then go to the relevant box plot and look along the x axis until we found the matching box. As it is, all we have to do is look for the matching color - we don&#39;t even necessarily need to know which stroke we&#39;re looking at. . Notice that when using this technique, we have to make sure that the orders of the categories match. In this case they do, but we could always enforce it by using the order and hue_order arguments. . Making custom qualitative palettes is straightforward; we just make a list of color names, hexes or RGB tuples: . sns.catplot( data=swimming[swimming[&quot;Distance (m)&quot;] == 100], kind=&quot;box&quot;, x=&quot;Stroke&quot;, y=&quot;Time (s)&quot;, palette=[&quot;salmon&quot;, &quot;gold&quot;, &quot;seagreen&quot;, &quot;indigo&quot;, &quot;firebrick&quot;], height=4, ) plt.title(&quot;Distribution of 100m swimming times for different strokes&quot;, y=1.05) . Text(0.5, 1.05, &#39;Distribution of 100m swimming times for different strokes&#39;) . One quirk of seaborn that we have to watch out for is the default behavior when picking palettes for categorical plots. If we make a categorical plot with up to 10 categories it will pick a qualitative palette by default: . sns.catplot( data=swimming[swimming[&quot;Distance (m)&quot;] == 100], kind=&quot;bar&quot;, y=&quot;Stroke&quot;, x=&quot;Time (s)&quot;, ) plt.title(&quot;Distribution of 100m swimming times for different strokes&quot;, y=1.05) . Text(0.5, 1.05, &#39;Distribution of 100m swimming times for different strokes&#39;) . but if we have more than 10 categories it will pick a sequential palette: . sns.catplot( data=swimming[swimming[&quot;Distance (m)&quot;] == 100], kind=&quot;bar&quot;, y=&quot;City&quot;, x=&quot;Time (s)&quot;, height=8, ) plt.title( &quot;Distribution of 100m swimming times for Olympics nheld in different cities&quot;, y=1.05, ) . Text(0.5, 1.05, &#39;Distribution of 100m swimming times for Olympics nheld in different cities&#39;) . leading to the kind of interpretation problems we saw before. Because of this behaviour it&#39;s quite easy, when exploring a dataset, to end up accidentally creating a chart with an inappropriate palette. The fix here would be to either specify an explicit qualitative palette, or use a single color. . Diverging palettes . The final type of palette that we need to consider requires a bit of explanation. Diverging palettes are sequential, in the sense that they are continuous - similar values map to similar colors. But they are intended for cases where we want some value in the middle of the range of values to be perceived as neutral. An example will make this clear. . Let&#39;s say we want to explore a pattern that we&#39;ve noticed before: the relationship between height and swimming performance. One way to do this is to consider each athlete&#39;s height in relative rather than absolute terms. In other words, for each athlete we want to know whether they are taller or shorter than average. . We know that men and women have different heights, so to simplify matters we&#39;ll just select the men for now and remove any with missing heights: . men = swimming[swimming[&quot;Sex&quot;] == &quot;M&quot;].dropna() . and make a new column by subtracting the median height from the athlete height: . men[&quot;Height compared nto median (cm)&quot;] = ( men[&quot;Height (cm)&quot;] - men[&quot;Height (cm)&quot;].median() ) men.head() . Name Country Age Sex Height (cm) ... Medal Time (s) Distance (m) Stroke Height compared nto median (cm) . 7 Charles Daniels | USA | 23 | M | 183.0 | ... | Gold | 65.0 | 100 | freestyle | -3.0 | . 10 Henry Taylor | GBR | 23 | M | 165.0 | ... | Gold | 336.0 | 400 | freestyle | -21.0 | . 11 Francis Beaurepaire | ANZ | 16 | M | 170.0 | ... | Silver | 344.0 | 400 | freestyle | -16.0 | . 13 Henry Taylor | GBR | 23 | M | 165.0 | ... | Gold | 1368.0 | 1500 | freestyle | -21.0 | . 15 Francis Beaurepaire | ANZ | 16 | M | 170.0 | ... | Bronze | 1376.0 | 1500 | freestyle | -16.0 | . 5 rows × 13 columns . This new column tells us, for each male athelete, whether they are taller or shorter than the median, and by how much. A useful trick when we have a long column name is to manually put a newline character in the middle of it - this looks odd when viewed as a table, but will work out well in figures. . Now let&#39;s use it in a chart. If we put our new column on an axis it&#39;s easy enough to interpret: points to the right of the center line represent athletes that are taller than average. The only tweak we might make is to set the x axis limits to make it symmetrical around the zero point: . mens_400m_freestyle = men[(men[&quot;Distance (m)&quot;] == 400) &amp; (men[&quot;Stroke&quot;] == &quot;freestyle&quot;)] sns.relplot(data=mens_400m_freestyle, x=&quot;Height compared nto median (cm)&quot;, y=&quot;Time (s)&quot;) plt.xlim(-40, 40) plt.title(&quot;Height relative to the median vs time n for mens&#39; 400m freestyle results&quot;) . Text(0.5, 1.0, &#34;Height relative to the median vs time n for mens&#39; 400m freestyle results&#34;) . This plot shows a pattern that we&#39;ve noticed before - that taller atheletes are faster - but looking at relative height in this way allows us to see some subtleties. We might say that while there isn&#39;t much of an advantage being taller than average, there is a great disadvantage being shorter. . When we use this new column as a hue, however, things get a bit trickier: . sns.relplot( data=men, x=&quot;Year&quot;, y=&quot;Weight (kg)&quot;, hue=&quot;Height compared nto median (cm)&quot;, ) plt.title(&quot;Male Olympic swimmers weight over time&quot;) . Text(0.5, 1.0, &#39;Male Olympic swimmers weight over time&#39;) . What we are really interested in seeing is, for each point, whether the height is above or below the average for men, i.e. whether the difference is positive or negative. But as we can see from the legend, the particular shade of purple that corresponds to zero isn&#39;t easy to pick out. We will have the same problem with any of the sequential palettes we have seen. . The solution is to use a diverging palette, which has a neutral color in the middle that we can use to represent zero. For example, the RdBu palette goes from red to blue, passing through white in the center. If we use that as our palette then the colors will be much easier to interpret: . sns.relplot( data=men, x=&quot;Year&quot;, y=&quot;Weight (kg)&quot;, hue=&quot;Height compared nto median (cm)&quot;, palette=&quot;RdBu&quot;, hue_norm=(-40, 40), # make zero the middle of the color scale ) plt.title(&quot;Male Olympic swimmers weight over time&quot;) . Text(0.5, 1.0, &#39;Male Olympic swimmers weight over time&#39;) . As we can see from the scale, red points are negative and blue points are positive, and the saturation of the color tells us how far away from zero each point is. This makes it easy to see the pattern that male swimmers below the median height have been getting fewer and fewer medals as time goes on. . Diverging palettes are useful whenever we want to show a value relative to some neutral point. We will make extensive use of diverging palettes when we discuss heatmaps, as it&#39;s in that context that they come into play most often. Here are the diverging palettes available: . fig, ax = plt.subplots() from scipy import ndimage i = plt.imread(&quot;colormaps_diverging.png&quot;) plt.imshow(ndimage.rotate(i, -90)) ax.axis(&quot;off&quot;) . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . (-0.5, 1499.5, 1499.5, -0.5) . Using color redundantly . One of the best uses of color in data visualization can be to add redundant information. We have already seen an example of this with our small multiple box plots. Let&#39;s look at the distribution of 100m times for athletes from different countries. We will use pandas to filter out a set of countries that we&#39;re interested in: . g = sns.catplot( data=swimming[ (swimming[&quot;Distance (m)&quot;] == 100) &amp; swimming[&quot;Country&quot;].isin([&quot;USA&quot;, &quot;AUS&quot;, &quot;JPN&quot;, &quot;NED&quot;, &quot;GDR&quot;]) ], kind=&quot;box&quot;, x=&quot;Country&quot;, y=&quot;Time (s)&quot;, palette=&quot;Dark2&quot;, height=3, col=&quot;Stroke&quot;, ) g.fig.suptitle( &quot;Distribution of 100m swimming time for athletes from different countries&quot;, y=1.05, ) . Text(0.5, 1.05, &#39;Distribution of 100m swimming time for athletes from different countries&#39;) . In this chart the color of each bar is redundant in the sense that it tells us the country, which we could also figure out by looking at the x axis labels. However, it&#39;s still useful. If we want to compare a given country for different strokes, it&#39;s much easier to find the matching color than the matching label on the x axis. . Try it: see how long it takes to figure out if there&#39;s a difference in the times between freestyle and butterfly for athletes from the Netherlands, then try to answer the same question using the monochrome version: . g = sns.catplot( data=swimming[ (swimming[&quot;Distance (m)&quot;] == 100) &amp; swimming[&quot;Country&quot;].isin([&quot;USA&quot;, &quot;AUS&quot;, &quot;JPN&quot;, &quot;NED&quot;, &quot;GDR&quot;]) ], kind=&quot;box&quot;, x=&quot;Country&quot;, y=&quot;Time (s)&quot;, color=&quot;lightskyblue&quot;, height=3, col=&quot;Stroke&quot;, ) g.fig.suptitle( &quot;Distribution of 100m swimming time for athletes from different countries&quot;, y=1.05, ) . Text(0.5, 1.05, &#39;Distribution of 100m swimming time for athletes from different countries&#39;) . When it comes to interpreting complex charts, redundancy is a good thing. By giving our visual system two aspects of the chart to focus on - in this case, color and X position - we make it easier to make comparisons. . The same is often true for other aspects. For example, we can use color and marker style redundantly in scatter plots: . g = sns.relplot( data=athletes, x=&quot;Height (cm)&quot;, y=&quot;Weight (kg)&quot;, hue=&quot;Sex&quot;, palette=&quot;Set1&quot;, style=&quot;Sex&quot;, ) g.fig.suptitle( &quot;Height vs weight for male (red circles) nand female (blue crosses) Olympic swimmers&quot;, y=1.1, ) . Text(0.5, 1.1, &#39;Height vs weight for male (red circles) nand female (blue crosses) Olympic swimmers&#39;) . Here we have red circles for male athletes and blue crosses for female ones. Of course, this means that we can&#39;t use color to display a third variable as we&#39;ve done before. . For numerical columns, it may be useful to use color and size together: . sns.relplot( data=mens_400m_freestyle, x=&quot;Year&quot;, y=&quot;Time (s)&quot;, hue=&quot;Height (cm)&quot;, palette=&quot;RdPu&quot;, size=&quot;Height (cm)&quot;, sizes=(2, 100), ) plt.title(&quot;Mens&#39; 400m freestyle times in each Olympic year&quot;) . Text(0.5, 1.0, &#34;Mens&#39; 400m freestyle times in each Olympic year&#34;) . This will doubly emphasize the largest values, which are now represented by points that are both bigger and more saturated. . We can do a similar thing by combining color with style in point plots by setting the linestyles argument to a list of strings representing the styles that we want: . sns.catplot( data=swimming[ (swimming[&quot;Distance (m)&quot;] == 400) &amp; (swimming[&quot;Stroke&quot;] == &quot;freestyle&quot;) ], x=&quot;Year&quot;, y=&quot;Time (s)&quot;, kind=&quot;point&quot;, hue=&quot;Sex&quot;, linestyles=[&quot;-&quot;, &quot;--&quot;], aspect=3, height=4, dodge=True, orient=&quot;v&quot;, ci=&quot;sd&quot;, ) plt.title( &quot;&quot;&quot;Mean and standard deviation of 400m freestyle times for each year for male and female Olympic swimmers&quot;&quot;&quot;, ) . Text(0.5, 1.0, &#39;Mean and standard deviation of 400m freestyle times nfor each year for male and female Olympic swimmers&#39;) . or in line plots by setting the style argument to the same column as hue: . sns.relplot( data=weather[weather[&quot;City&quot;].isin([&quot;Berlin&quot;, &quot;Edinburgh&quot;])], x=&quot;Day of year&quot;, y=&quot;Mean temperature&quot;, hue=&quot;City&quot;, aspect=3, height=4, kind=&quot;line&quot;, style=&quot;City&quot;, ci=&quot;sd&quot;, ) plt.title( &quot;Mean daily temperature for each day of the year nsince 1960 in Berlin and Edinburgh&quot; ) . Text(0.5, 1.0, &#39;Mean daily temperature for each day of the year nsince 1960 in Berlin and Edinburgh&#39;) . This only works well for small numbers of different styles. . Another way that we can use color redundantly is to use it to display some extra information about a category. Let&#39;s look at female swimmers this time, and add an event column: . women = swimming[swimming[&quot;Sex&quot;] == &quot;W&quot;] women[&quot;Event&quot;] = swimming[&quot;Distance (m)&quot;].astype(str) + &quot; &quot; + swimming[&quot;Stroke&quot;] women . Name Country Age Sex Height (cm) ... Medal Time (s) Distance (m) Stroke Event . 22 Fanny Durack | ANZ | &lt;NA&gt; | W | NaN | ... | Gold | 82.0 | 100 | freestyle | 100 freestyle | . 23 Wilhelmina Wylie | ANZ | 20 | W | NaN | ... | Silver | 85.0 | 100 | freestyle | 100 freestyle | . 24 Jennie Fletcher | GBR | &lt;NA&gt; | W | NaN | ... | Bronze | 87.0 | 100 | freestyle | 100 freestyle | . 40 Ethelda Bleibtrey | USA | &lt;NA&gt; | W | NaN | ... | Gold | 73.0 | 100 | freestyle | 100 freestyle | . 41 Irene Guest | USA | &lt;NA&gt; | W | NaN | ... | Silver | 77.0 | 100 | freestyle | 100 freestyle | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1297 Penny Oleksiak | CAN | &lt;NA&gt; | W | NaN | ... | Silver | 56.0 | 100 | butterfly | 100 butterfly | . 1298 Dana Vollmer | USA | &lt;NA&gt; | W | NaN | ... | Bronze | 56.0 | 100 | butterfly | 100 butterfly | . 1303 Mireia Belmonte Garcia | ESP | &lt;NA&gt; | W | NaN | ... | Gold | 124.0 | 200 | butterfly | 200 butterfly | . 1304 Madeline Groves | AUS | 21 | W | 179.0 | ... | Silver | 124.0 | 200 | butterfly | 200 butterfly | . 1305 Natsumi Hoshi | JPN | 25 | W | 164.0 | ... | Bronze | 125.0 | 200 | butterfly | 200 butterfly | . 618 rows × 13 columns . This will allow us to make a bar chart showing the times: . sns.catplot( data=women, kind=&quot;bar&quot;, x=&quot;Event&quot;, y=&quot;Time (s)&quot;, aspect=2, color=&quot;lightblue&quot;, orient=&quot;v&quot;, ) plt.title(&quot;Mean and 95% CI for womens&#39; Olympic swimming events&quot;) plt.xticks(rotation=45, horizontalalignment=&quot;right&quot;) . (array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), [Text(0, 0, &#39;100 freestyle&#39;), Text(1, 0, &#39;400 freestyle&#39;), Text(2, 0, &#39;100 backstroke&#39;), Text(3, 0, &#39;200 breaststroke&#39;), Text(4, 0, &#39;100 butterfly&#39;), Text(5, 0, &#39;400 medley&#39;), Text(6, 0, &#39;200 freestyle&#39;), Text(7, 0, &#39;800 freestyle&#39;), Text(8, 0, &#39;200 medley&#39;), Text(9, 0, &#39;200 backstroke&#39;), Text(10, 0, &#39;100 breaststroke&#39;), Text(11, 0, &#39;200 butterfly&#39;), Text(12, 0, &#39;50 freestyle&#39;)]) . Each event has the stroke as part of its name, and so in principle we could figure out which stoke each bar belongs to by reading its X axis label. It would be much easier, however, if we used color to represent stroke: . sns.catplot( data=women, kind=&quot;bar&quot;, x=&quot;Event&quot;, y=&quot;Time (s)&quot;, aspect=2, hue=&quot;Stroke&quot;, orient=&quot;v&quot;, ) plt.title(&quot;Mean and 95% CI for womens&#39; Olympic swimming events&quot;) plt.xticks(rotation=45, horizontalalignment=&quot;right&quot;) . (array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), [Text(0, 0, &#39;100 freestyle&#39;), Text(1, 0, &#39;400 freestyle&#39;), Text(2, 0, &#39;100 backstroke&#39;), Text(3, 0, &#39;200 breaststroke&#39;), Text(4, 0, &#39;100 butterfly&#39;), Text(5, 0, &#39;400 medley&#39;), Text(6, 0, &#39;200 freestyle&#39;), Text(7, 0, &#39;800 freestyle&#39;), Text(8, 0, &#39;200 medley&#39;), Text(9, 0, &#39;200 backstroke&#39;), Text(10, 0, &#39;100 breaststroke&#39;), Text(11, 0, &#39;200 butterfly&#39;), Text(12, 0, &#39;50 freestyle&#39;)]) . Notice the problem with this chart: the bars are very narrow and unevenly spaced. This is because seaborn doesn&#39;t &quot;know&quot; that each event belongs to one stroke, so it is leaving enough space for 5 bars - one per stroke - at each X axis label. To avoid this, set dodge to False: . sns.catplot( data=women, kind=&quot;bar&quot;, x=&quot;Event&quot;, y=&quot;Time (s)&quot;, aspect=2, hue=&quot;Stroke&quot;, dodge=False, orient=&quot;v&quot;, ) plt.title(&quot;Mean and 95% CI for womens&#39; Olympic swimming events&quot;) plt.xticks(rotation=45, horizontalalignment=&quot;right&quot;) . (array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), [Text(0, 0, &#39;100 freestyle&#39;), Text(1, 0, &#39;400 freestyle&#39;), Text(2, 0, &#39;100 backstroke&#39;), Text(3, 0, &#39;200 breaststroke&#39;), Text(4, 0, &#39;100 butterfly&#39;), Text(5, 0, &#39;400 medley&#39;), Text(6, 0, &#39;200 freestyle&#39;), Text(7, 0, &#39;800 freestyle&#39;), Text(8, 0, &#39;200 medley&#39;), Text(9, 0, &#39;200 backstroke&#39;), Text(10, 0, &#39;100 breaststroke&#39;), Text(11, 0, &#39;200 butterfly&#39;), Text(12, 0, &#39;50 freestyle&#39;)]) . Incidentally, for this chart the default ordering on the X axis make little sense - the events appear simply in the order that they appear in the data. We can specify an order using order - for example, we could organize the bars by stroke: . labels_order = [&#39;50 freestyle&#39;,&#39;100 freestyle&#39;,&#39;200 freestyle&#39;,&#39;400 freestyle&#39;,&#39;800 freestyle&#39;, &#39;100 backstroke&#39;,&#39;200 backstroke&#39;, &#39;100 breaststroke&#39;,&#39;200 breaststroke&#39;, &#39;100 butterfly&#39;,&#39;200 butterfly&#39;, &#39;200 medley&#39;,&#39;400 medley&#39;] sns.catplot( data=women, kind=&quot;bar&quot;, x=&quot;Event&quot;, y=&quot;Time (s)&quot;, aspect=2, hue=&#39;Stroke&#39;, dodge=False, orient=&quot;v&quot;, order = labels_order ) plt.title(&quot;Mean and 95% CI for womens&#39; Olympic swimming events&quot;) plt.xticks(rotation=45, horizontalalignment=&quot;right&quot;) . (array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), [Text(0, 0, &#39;50 freestyle&#39;), Text(1, 0, &#39;100 freestyle&#39;), Text(2, 0, &#39;200 freestyle&#39;), Text(3, 0, &#39;400 freestyle&#39;), Text(4, 0, &#39;800 freestyle&#39;), Text(5, 0, &#39;100 backstroke&#39;), Text(6, 0, &#39;200 backstroke&#39;), Text(7, 0, &#39;100 breaststroke&#39;), Text(8, 0, &#39;200 breaststroke&#39;), Text(9, 0, &#39;100 butterfly&#39;), Text(10, 0, &#39;200 butterfly&#39;), Text(11, 0, &#39;200 medley&#39;), Text(12, 0, &#39;400 medley&#39;)]) . or arrange the from highest to lowest mean time. We will see how to do this programatically in a future chapter but for now we will just write a literal list: . labels_order = [&#39;50 freestyle&#39;, &#39;100 butterfly&#39;, &#39;100 freestyle&#39;, &#39;100 backstroke&#39;, &#39;100 breaststroke&#39;, &#39;200 freestyle&#39;, &#39;200 butterfly&#39;, &#39;200 backstroke&#39;, &#39;200 medley&#39;, &#39;200 breaststroke&#39;, &#39;400 freestyle&#39;, &#39;400 medley&#39;, &#39;800 freestyle&#39;] sns.catplot( data=women, kind=&quot;bar&quot;, x=&quot;Event&quot;, y=&quot;Time (s)&quot;, aspect=2, hue=&#39;Stroke&#39;, dodge=False, orient=&quot;v&quot;, order = labels_order ) plt.title(&quot;Mean and 95% CI for womens&#39; Olympic swimming events&quot;) plt.xticks(rotation=45, horizontalalignment=&quot;right&quot;) . (array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), [Text(0, 0, &#39;50 freestyle&#39;), Text(1, 0, &#39;100 butterfly&#39;), Text(2, 0, &#39;100 freestyle&#39;), Text(3, 0, &#39;100 backstroke&#39;), Text(4, 0, &#39;100 breaststroke&#39;), Text(5, 0, &#39;200 freestyle&#39;), Text(6, 0, &#39;200 butterfly&#39;), Text(7, 0, &#39;200 backstroke&#39;), Text(8, 0, &#39;200 medley&#39;), Text(9, 0, &#39;200 breaststroke&#39;), Text(10, 0, &#39;400 freestyle&#39;), Text(11, 0, &#39;400 medley&#39;), Text(12, 0, &#39;800 freestyle&#39;)]) . This technique of using color to show extra information about categories can be very flexible when we combine it with pandas processing. We can add arbitrary categories to our data points, then map those to color. . For example, let&#39;s take our swimming results and classify each event as either long or short. For our purposes, we will arbitrarily say that any event that&#39;s at least 400m counts as long. The easiest way to do this is to write a function that will take the a distance and return the answer we want: . def classify_distance(distance): if distance &gt;= 400: return &quot;Long&quot; else: return &quot;Short&quot; . and then use apply to run it on each of our distance values: . swimming[&quot;Distance (m)&quot;].apply(classify_distance) . 0 Short 1 Short 2 Short 3 Short 4 Short ... 1304 Short 1305 Short 1306 Short 1307 Short 1308 Short Name: Distance (m), Length: 1309, dtype: object . Once we have our resulting series of classifications, we can add it as a new column: . women[&quot;Race type&quot;] = women[&quot;Distance (m)&quot;].apply(classify_distance) women.head() . Name Country Age Sex Height (cm) ... Time (s) Distance (m) Stroke Event Race type . 22 Fanny Durack | ANZ | &lt;NA&gt; | W | NaN | ... | 82.0 | 100 | freestyle | 100 freestyle | Short | . 23 Wilhelmina Wylie | ANZ | 20 | W | NaN | ... | 85.0 | 100 | freestyle | 100 freestyle | Short | . 24 Jennie Fletcher | GBR | &lt;NA&gt; | W | NaN | ... | 87.0 | 100 | freestyle | 100 freestyle | Short | . 40 Ethelda Bleibtrey | USA | &lt;NA&gt; | W | NaN | ... | 73.0 | 100 | freestyle | 100 freestyle | Short | . 41 Irene Guest | USA | &lt;NA&gt; | W | NaN | ... | 77.0 | 100 | freestyle | 100 freestyle | Short | . 5 rows × 14 columns . And now we can use it as a categorical variable. Because all the events with the same distance will obviously have the same race type, we need to use dodge = False when using it in conjunction with event as the main variable: . labels_order = [ &quot;50 freestyle&quot;, &quot;100 freestyle&quot;, &quot;200 freestyle&quot;, &quot;400 freestyle&quot;, &quot;800 freestyle&quot;, &quot;100 backstroke&quot;, &quot;200 backstroke&quot;, &quot;100 breaststroke&quot;, &quot;200 breaststroke&quot;, &quot;100 butterfly&quot;, &quot;200 butterfly&quot;, &quot;200 medley&quot;, &quot;400 medley&quot;, ] sns.catplot( data=women, kind=&quot;bar&quot;, x=&quot;Event&quot;, y=&quot;Time (s)&quot;, aspect=2, hue=&quot;Race type&quot;, palette=&quot;Set3&quot;, dodge=False, orient=&quot;v&quot;, order=labels_order, ) plt.title( &quot;Mean and 95% CI for short (green) and long (yellow) womens&#39; Olympic swimming events&quot; ) plt.xticks(rotation=45, horizontalalignment=&quot;right&quot;) . (array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]), [Text(0, 0, &#39;50 freestyle&#39;), Text(1, 0, &#39;100 freestyle&#39;), Text(2, 0, &#39;200 freestyle&#39;), Text(3, 0, &#39;400 freestyle&#39;), Text(4, 0, &#39;800 freestyle&#39;), Text(5, 0, &#39;100 backstroke&#39;), Text(6, 0, &#39;200 backstroke&#39;), Text(7, 0, &#39;100 breaststroke&#39;), Text(8, 0, &#39;200 breaststroke&#39;), Text(9, 0, &#39;100 butterfly&#39;), Text(10, 0, &#39;200 butterfly&#39;), Text(11, 0, &#39;200 medley&#39;), Text(12, 0, &#39;400 medley&#39;)]) . A similar trick is to highlight a single category by giving it a different color to the rest. We can do this by combinig the order and palette arguments to catplot. Returning to our example where we are drawing a boxplot of times for each stroke, here&#39;s how we can highlight butterfly subtly: . g = sns.catplot( data=swimming[swimming[&quot;Distance (m)&quot;] == 100], kind=&quot;box&quot;, x=&quot;Stroke&quot;, y=&quot;Time (s)&quot;, height=4, col=&quot;Sex&quot;, palette=[&quot;goldenrod&quot;, &quot;goldenrod&quot;, &quot;saddlebrown&quot;, &quot;goldenrod&quot;], ) g.fig.suptitle(&quot;Distribution of 100m Olympic medal times for different strokes&quot;, y=1.05) . Text(0.5, 1.05, &#39;Distribution of 100m Olympic medal times for different strokes&#39;) . or more strikingly: . g = sns.catplot( data=swimming[swimming[&quot;Distance (m)&quot;] == 100], kind=&quot;box&quot;, x=&quot;Stroke&quot;, y=&quot;Time (s)&quot;, height=4, col=&quot;Sex&quot;, palette=[&quot;white&quot;, &quot;white&quot;, &quot;red&quot;, &quot;white&quot;], ) g.fig.suptitle(&quot;Distribution of 100m Olympic medal times for different strokes&quot;, y=1.05) . Text(0.5, 1.05, &#39;Distribution of 100m Olympic medal times for different strokes&#39;) . Consistency with colors . As we&#39;ve seen in earlier examples, using colors consistently between charts can be a great aid to interpretation. Conversely, inconsistent use of color can cause all sorts of problems. One trap that we can fall into is to draw two charts with the same categories and palettes, but different category orders. . Here are two charts that show the distribution of heights of female athletes from a selected list of countries. The first just shows bronze medal winners: . my_countries = [&quot;USA&quot;, &quot;AUS&quot;, &quot;CHN&quot;, &quot;JPN&quot;, &quot;GBR&quot;, &quot;GER&quot;, &quot;ITA&quot;, &quot;CAN&quot;] selected_women = women[women[&quot;Country&quot;].isin(my_countries)] sns.catplot( data=selected_women[selected_women[&quot;Medal&quot;] == &quot;Bronze&quot;], x=&quot;Country&quot;, y=&quot;Height (cm)&quot;, palette=&quot;Accent&quot;, kind=&quot;box&quot;, aspect=2, ) plt.title(&quot;Distribution of heights across female Olympic swimming bronze medal winners&quot;) . Text(0.5, 1.0, &#39;Distribution of heights across female Olympic swimming bronze medal winners&#39;) . The second plot shows the same data for gold and silver medal winners: . sns.catplot( data=selected_women[selected_women[&quot;Medal&quot;].isin([&quot;Gold&quot;, &quot;Silver&quot;])], x=&quot;Country&quot;, y=&quot;Height (cm)&quot;, palette=&quot;Accent&quot;, kind=&quot;box&quot;, aspect=2, ) plt.title( &quot;Distribution of heights across female Olympic swimming gold and silver medal winners&quot; ) . Text(0.5, 1.0, &#39;Distribution of heights across female Olympic swimming gold and silver medal winners&#39;) . In the above pair of plots we have divided our dataset into two subsets and plotted them separately. Because the order (and hence the color) of the countries is determined by the order that they appear in the data, it&#39;s different for each chart. Notice that for the bronze medal plot, the first green box represents Great Britain, but in the gold/silver plot, the green box represents the USA. . Either chart in isolation would be fine, but together this is a disaster for interpretation - looking at boxes of the same color and position might mean that we are accidentally comparing two different counties. . One solution is to have an explicit order for the countries, which we define once at the start of the project: . my_countries = [&quot;USA&quot;, &quot;AUS&quot;, &quot;CHN&quot;, &quot;JPN&quot;, &quot;GBR&quot;, &quot;GER&quot;, &quot;ITA&quot;, &quot;CAN&quot;] . and then reuse each time we draw a chart: . sns.catplot( data=selected_women[selected_women[&quot;Medal&quot;].isin([&quot;Gold&quot;, &quot;Silver&quot;])], x=&quot;Country&quot;, y=&quot;Height (cm)&quot;, palette=&quot;Accent&quot;, kind=&quot;box&quot;, aspect=2, order=my_countries, ) plt.title(&quot;Distribution of heights across female Olympic swimming bronze medal winners&quot;) . Text(0.5, 1.0, &#39;Distribution of heights across female Olympic swimming bronze medal winners&#39;) . This forces a consistent order. Another option would be to make a new categorical column containing the property that we want to use to split the data up. This is covered in detail in the chapter on binning, so we&#39;ll do it briefly here: . selected_women[&quot;Medal type&quot;] = selected_women[&quot;Medal&quot;].apply( lambda m: &quot;Gold and Silver&quot; if m in [&quot;Gold&quot;, &quot;Silver&quot;] else &quot;Bronze&quot; ) selected_women.head() . Name Country Age Sex Height (cm) ... Distance (m) Stroke Event Race type Medal type . 24 Jennie Fletcher | GBR | &lt;NA&gt; | W | NaN | ... | 100 | freestyle | 100 freestyle | Short | Bronze | . 40 Ethelda Bleibtrey | USA | &lt;NA&gt; | W | NaN | ... | 100 | freestyle | 100 freestyle | Short | Gold and Silver | . 41 Irene Guest | USA | &lt;NA&gt; | W | NaN | ... | 100 | freestyle | 100 freestyle | Short | Gold and Silver | . 42 Frances Schroth | USA | 27 | W | 168.0 | ... | 100 | freestyle | 100 freestyle | Short | Bronze | . 58 Ethel Lackie | USA | &lt;NA&gt; | W | NaN | ... | 100 | freestyle | 100 freestyle | Short | Gold and Silver | . 5 rows × 15 columns . Now we can use catplot to separate out the two categories in a single chart, and it will take care of enforcing a consistent order between the individual plots: . g = sns.catplot( data=selected_women, x=&quot;Country&quot;, y=&quot;Height (cm)&quot;, palette=&quot;Accent&quot;, kind=&quot;box&quot;, aspect=1, col=&quot;Medal type&quot;, ) g.fig.suptitle( &quot;Distribution of heights across female Olympic swimming medal winners from different countries&quot;, y=1.05, ) . Text(0.5, 1.05, &#39;Distribution of heights across female Olympic swimming medal winners from different countries&#39;) . The final approach to ensure consistency between charts would be to make the Country column an ordered category. We&#39;ll discuss this in a later chapter. . Reusing palettes for different categories . Another problem that&#39;s easy to run into is accidentally using the same palettes for different categories. Let&#39;s say we start a project by looking at the distribution of female athlete heights for all medal winners, using a similar chart to the examples above: . g = sns.catplot( data=selected_women, x=&quot;Country&quot;, y=&quot;Height (cm)&quot;, palette=&quot;Accent&quot;, kind=&quot;box&quot;, ) plt.title(&quot;Distribution of heights nof female Olympic swimming medal winners&quot;) . Text(0.5, 1.0, &#39;Distribution of heights nof female Olympic swimming medal winners&#39;) . Then later we draw another chart that uses color to represent a different category: . sns.relplot( data=selected_women, x=&quot;Height (cm)&quot;, y=&quot;Weight (kg)&quot;, hue=&quot;Stroke&quot;, palette=&quot;Accent&quot;, aspect=2, s=40, ) plt.title(&quot;Height vs weight for female Olympic swimmers competing in different strokes&quot;) . Text(0.5, 1.0, &#39;Height vs weight for female Olympic swimmers competing in different strokes&#39;) . When interpreting these two charts, it&#39;s going to be very tempting to assume that the dark blue points in the scatter plot correspond to the dark blue box in the box plot. Of course, this is misleading as the two charts are grouping the athletes in completely different ways. Dark blue in the scatter plot represents medley, whereas dark blue in the box plot represents Japan. . The easiest way to avoid this is to simply use a different palette for one of the charts: . sns.relplot( data=selected_women, x=&quot;Height (cm)&quot;, y=&quot;Weight (kg)&quot;, hue=&quot;Stroke&quot;, palette=&quot;Set1&quot;, aspect=2, s=40, ) plt.title(&quot;Height vs weight for female Olympic swimmers competing in different strokes&quot;) . Text(0.5, 1.0, &#39;Height vs weight for female Olympic swimmers competing in different strokes&#39;) . In fact, it&#39;s a good idea to get into the habit of always specifying a palette when using hue, even if it&#39;s just to pick the default (&#39;Set1&#39;). .",
            "url": "https://mojones.github.io/dfd_jupyter_test/2020/10/25/_Working_with_colour_in_seaborn.html",
            "relUrl": "/2020/10/25/_Working_with_colour_in_seaborn.html",
            "date": " • Oct 25, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master- badges: true- comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://mojones.github.io/dfd_jupyter_test/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://mojones.github.io/dfd_jupyter_test/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://mojones.github.io/dfd_jupyter_test/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://mojones.github.io/dfd_jupyter_test/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}